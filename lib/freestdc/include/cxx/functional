#ifndef _FREESTDC_CXX_FUNCTIONAL_
#define _FREESTDC_CXX_FUNCTIONAL_

#include "cxx_basedefs.hh"
#include "utility"

namespace std {
	template <typename F, typename... Args>
	FREESTDC_CONSTEXPR_SINCE_CXX20 auto invoke(F &&f, Args &&...args)
		-> decltype(__builtin_invoke(std::forward<F>(f), std::forward<Args>(args)...)) {
		return __builtin_invoke(std::forward<F>(f), std::forward<Args>(args)...);
	}

	template <typename T>
	struct plus {
		constexpr T operator()(const T &x, const T &y) const {
			return x + y;
		}
	};

	template <>
	struct plus<void> {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const
			-> decltype(std::forward<T>(t) + std::forward<U>(u)) {
			return static_cast<T &&>(t) + static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct minus {
		constexpr T operator()(const T &x, const T &y) const {
			return x - y;
		}
	};

	template <>
	struct minus<void> {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const
			-> decltype(std::forward<T>(t) - std::forward<U>(u)) {
			return static_cast<T &&>(t) - static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct multiplies {
		constexpr T operator()(const T &x, const T &y) const {
			return x * y;
		}
	};

	template <>
	struct multiplies<void> {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const
			-> decltype(std::forward<T>(t) * std::forward<U>(u)) {
			return static_cast<T &&>(t) * static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct divides {
		constexpr T operator()(const T &x, const T &y) const {
			return x / y;
		}
	};

	template <>
	struct divides<void> {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const
			-> decltype(std::forward<T>(t) / std::forward<U>(u)) {
			return static_cast<T &&>(t) / static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct modulus {
		constexpr T operator()(const T &x, const T &y) const {
			return x % y;
		}
	};

	template <>
	struct modulus<void> {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const
			-> decltype(std::forward<T>(t) % std::forward<U>(u)) {
			return static_cast<T &&>(t) % static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct negate {
		constexpr T operator()(const T &x) const {
			return -x;
		}
	};

	template <>
	struct negate<void> {
		template <class T>
		constexpr auto operator()(T &&t) const
			-> decltype(-std::forward<T>(t)) {
			return -static_cast<T &&>(t);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct equal_to {
		constexpr bool operator()(const T &x, const T &y) const {
			return x == y;
		}
	};

	template <>
	struct equal_to<void> {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const
			-> decltype(std::forward<T>(t) == std::forward<U>(u)) {
			return static_cast<T &&>(t) == static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct not_equal_to {
		constexpr bool operator()(const T &x, const T &y) const {
			return x != y;
		}
	};

	template <>
	struct not_equal_to<void> {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const
			-> decltype(std::forward<T>(t) != std::forward<U>(u)) {
			return static_cast<T &&>(t) != static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct greater {
		constexpr bool operator()(const T &x, const T &y) const {
			return x > y;
		}
	};

	template <>
	struct greater<void> {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const
			-> decltype(std::forward<T>(t) > std::forward<U>(u)) {
			return static_cast<T &&>(t) > static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct less {
		constexpr bool operator()(const T &x, const T &y) const {
			return x < y;
		}
	};

	template <>
	struct less<void> {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const
			-> decltype(std::forward<T>(t) < std::forward<U>(u)) {
			return static_cast<T &&>(t) < static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct greater_equal {
		constexpr bool operator()(const T &x, const T &y) const {
			return x >= y;
		}
	};

	template <>
	struct greater_equal<void> {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const
			-> decltype(std::forward<T>(t) >= std::forward<U>(u)) {
			return static_cast<T &&>(t) >= static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct less_equal {
		constexpr bool operator()(const T &x, const T &y) const {
			return x <= y;
		}
	};

	template <>
	struct less_equal<void> {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const
			-> decltype(std::forward<T>(t) <= std::forward<U>(u)) {
			return static_cast<T &&>(t) <= static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct logical_and {
		constexpr bool operator()(const T &x, const T &y) const {
			return x && y;
		}
	};

	template <>
	struct logical_and<void> {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const
			-> decltype(std::forward<T>(t) && std::forward<U>(u)) {
			return static_cast<T &&>(t) && static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct logical_or {
		constexpr bool operator()(const T &x, const T &y) const {
			return x || y;
		}
	};

	template <>
	struct logical_or<void> {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const
			-> decltype(std::forward<T>(t) || std::forward<U>(u)) {
			return static_cast<T &&>(t) || static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct logical_not {
		constexpr bool operator()(const T &x) const {
			return !x;
		}
	};

	template <>
	struct logical_not<void> {
		template <class T>
		constexpr auto operator()(T &&t) const
			-> decltype(!std::forward<T>(t)) {
			return !static_cast<T &&>(t);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct bit_and {
		constexpr T operator()(const T &x, const T &y) const {
			return x & y;
		}
	};

	template <>
	struct bit_and<void> {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const
			-> decltype(std::forward<T>(t) & std::forward<U>(u)) {
			return static_cast<T &&>(t) & static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct bit_or {
		constexpr T operator()(const T &x, const T &y) const {
			return x | y;
		}
	};

	template <>
	struct bit_or<void> {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const
			-> decltype(std::forward<T>(t) | std::forward<U>(u)) {
			return static_cast<T &&>(t) | static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct bit_xor {
		constexpr T operator()(const T &x, const T &y) const {
			return x ^ y;
		}
	};

	template <>
	struct bit_xor<void> {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const
			-> decltype(std::forward<T>(t) ^ std::forward<U>(u)) {
			return static_cast<T &&>(t) ^ static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	template <class T = void>
	struct bit_not {
		constexpr T operator()(const T &x) const {
			return ~x;
		}
	};

	template <>
	struct bit_not<void> {
		template <class T>
		constexpr auto operator()(T &&t) const
			-> decltype(~std::forward<T>(t)) {
			return ~static_cast<T &&>(t);
		}

		using is_transparent = int;
	};

#if __cplusplus >= 202002L
	struct compare_three_way {
		template <class T, class U>
		constexpr auto operator()(T &&t, U &&u) const {
			return static_cast<T &&>(t) <=> static_cast<U &&>(u);
		}

		using is_transparent = int;
	};

	struct identity {
		template <class T>
		constexpr T &&operator()(T &&t) const noexcept;

		using is_transparent = int;
	};
#endif
}

#endif
